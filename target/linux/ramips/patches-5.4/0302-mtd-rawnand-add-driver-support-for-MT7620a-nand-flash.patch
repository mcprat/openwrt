--- a/drivers/mtd/nand/raw/Kconfig
+++ b/drivers/mtd/nand/raw/Kconfig
@@ -391,6 +391,13 @@ config MTD_NAND_QCOM
 	  Enables support for NAND flash chips on SoCs containing the EBI2 NAND
 	  controller. This controller is found on IPQ806x SoC.
 
+config MTD_NAND_RALINK
+	tristate "RT28xx and MT7620 NAND controller"
+	depends on SOC_MT7620 || COMPILE_TEST
+	depends on HAS_IOMEM
+	help
+	  Enables support for NAND controller on MT7620 SoC.
+
 config MTD_NAND_MT7621
 	tristate "MT7621 NAND controller"
 	depends on SOC_MT7621 || COMPILE_TEST
--- a/drivers/mtd/nand/raw/Makefile
+++ b/drivers/mtd/nand/raw/Makefile
@@ -52,6 +52,7 @@ obj-$(CONFIG_MTD_NAND_SUNXI)		+= sunxi_n
 obj-$(CONFIG_MTD_NAND_HISI504)	        += hisi504_nand.o
 obj-$(CONFIG_MTD_NAND_BRCMNAND)		+= brcmnand/
 obj-$(CONFIG_MTD_NAND_QCOM)		+= qcom_nandc.o
+obj-$(CONFIG_MTD_NAND_RALINK)		+= ralink_nand.o
 obj-$(CONFIG_MTD_NAND_MT7621)		+= mt7621_nand.o
 obj-$(CONFIG_MTD_NAND_MTK)		+= mtk_ecc.o mtk_nand.o
 obj-$(CONFIG_MTD_NAND_MXIC)		+= mxic_nand.o
--- /dev/null
+++ b/drivers/mtd/nand/raw/ralink_nand.c
@@ -0,0 +1,292 @@
+// SPDX-License-Identifier: GPL-2.0
+
+/*
+ * Ralink NAND Flash Controller driver
+ *
+ * Copyright (C) 2020 MediaTek Inc. All Rights Reserved.
+ *
+ * Author: Weijie Gao <weijie.gao@mediatek.com>
+ */
+
+#include <linux/clk.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/sizes.h>
+#include <linux/iopoll.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/rawnand.h>
+#include <linux/mtd/partitions.h>
+#include <linux/platform_device.h>
+#include <asm/addrspace.h>
+
+#include <asm/mach-ralink/ralink_regs.h>
+
+#include "ralink_nand.h"
+
+struct ralink_nfc {
+	struct nand_controller controller;
+	struct nand_chip nand;
+	struct clk *nfi_clk;
+	struct device *dev;
+
+	int irq
+
+	void __iomem *nfi_regs;
+	void __iomem *ecc_regs;
+	void __iomem *addr_reg;
+
+	u32 spare_per_sector;
+};
+
+static const u16 ralink_nfi_page_size[] = { SZ_512, SZ_2K };
+static const u8 ralink_nfi_spare_size[] = { 16 };
+static const u8 ralink_ecc_strength[] = { 1 };
+
+static inline u32 nfi_read32(struct ralink_nfc *nfc, u32 reg)
+{
+	return readl(nfc->nfi_regs + reg);
+}
+
+static inline void nfi_write32(struct ralink_nfc *nfc, u32 reg, u32 val)
+{
+	writel(val, nfc->nfi_regs + reg);
+}
+
+static inline u16 nfi_read16(struct ralink_nfc *nfc, u32 reg)
+{
+	return readw(nfc->nfi_regs + reg);
+}
+
+static inline void nfi_write16(struct ralink_nfc *nfc, u32 reg, u16 val)
+{
+	writew(val, nfc->nfi_regs + reg);
+}
+
+static inline void ecc_write16(struct ralink_nfc *nfc, u32 reg, u16 val)
+{
+	writew(val, nfc->ecc_regs + reg);
+}
+
+static inline u32 ecc_read32(struct ralink_nfc *nfc, u32 reg)
+{
+	return readl(nfc->ecc_regs + reg);
+}
+
+static inline void ecc_write32(struct ralink_nfc *nfc, u32 reg, u32 val)
+{
+	return writel(val, nfc->ecc_regs + reg);
+}
+
+static inline u32 addr_read32(struct ralink_nfc *nfc, u32 addr)
+{
+	return readl(nfc->addr_reg + addr);
+}
+
+static inline void addr_write32(struct ralink_nfc *nfc, u32 addr, u32 val)
+{
+	return writel(val, nfc->addr_reg + addr);
+}
+
+static inline u8 *oob_fdm_ptr(struct nand_chip *nand, int sect)
+{
+	return nand->oob_poi + sect * NFI_FDM_SIZE;
+}
+
+static inline u8 *oob_ecc_ptr(struct ralink_nfc *nfc, int sect)
+{
+	struct nand_chip *nand = &nfc->nand;
+
+	return nand->oob_poi + nand->ecc.steps * NFI_FDM_SIZE +
+		sect * (nfc->spare_per_sector - NFI_FDM_SIZE);
+}
+
+static inline u8 *page_data_ptr(struct nand_chip *nand, const u8 *buf, int sect)
+{
+	return (u8 *)buf + sect * nand->ecc.size;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+static const struct nand_controller_ops ralink_nfc_controller_ops = {
+	.attach_chip = ralink_nfc_attach_chip,
+	.exec_op = ralink_nfc_exec_op,
+	.setup_data_interface = ralink_nfc_setup_data_interface,
+};
+
+static const struct mtd_ooblayout_ops ralink_nfc_ooblayout_ops = {
+	.free = ralink_nfc_ooblayout_free,
+	.ecc = ralink_nfc_ooblayout_ecc,
+};
+
+static int ralink_nfc_init_chip(struct ralink_nfc *nfc)
+{
+	struct nand_chip *nand = &nfc->nand;
+	struct mtd_info *mtd;
+	int ret;
+
+	nand->controller = &nfc->controller;
+	nand_set_controller_data(nand, (void *)nfc);
+	nand_set_flash_node(nand, nfc->dev->of_node);
+
+	nand->options |= NAND_USE_BOUNCE_BUFFER | NAND_NO_SUBPAGE_WRITE;
+	if (!nfc->nfi_clk)
+		nand->options |= NAND_KEEP_TIMINGS;
+
+	nand->ecc.mode = NAND_ECC_HW_SYNDROME;
+	nand->ecc.read_page = ralink_nfc_read_page_hwecc;
+	nand->ecc.read_page_raw = ralink_nfc_read_page_raw;
+	nand->ecc.write_page = ralink_nfc_write_page_hwecc;
+	nand->ecc.write_page_raw = ralink_nfc_write_page_raw;
+	nand->ecc.read_oob = ralink_nfc_read_oob_hwecc;
+	nand->ecc.read_oob_raw = ralink_nfc_read_oob_raw;
+	nand->ecc.write_oob = ralink_nfc_write_oob_hwecc;
+	nand->ecc.write_oob_raw = ralink_nfc_write_oob_raw;
+
+	mtd = nand_to_mtd(nand);
+	mtd->owner = THIS_MODULE;
+	mtd->dev.parent = nfc->dev;
+	mtd->name = MODULE_NAME;
+
+	mtd_set_ooblayout(mtd, &ralink_nfc_ooblayout_ops);
+
+	ralink_nfc_hw_init(nfc);
+
+	ret = nand_scan(nand, 1);
+	if (ret)
+		return ret;
+
+	ret = mtd_device_register(mtd, NULL, 0);
+	if (ret) {
+		dev_err(nfc->dev, "Failed to register MTD: %d\n", ret);
+		nand_release(nand);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int ralink_nfc_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct ralink_nfc *nfc;
+	struct resource *res;
+	int ret;
+
+	nfc = devm_kzalloc(dev, sizeof(*nfc), GFP_KERNEL);
+	if (!nfc)
+		return -ENOMEM;
+
+	nand_controller_init(&nfc->controller);
+	nfc->controller.ops = &ralink_nfc_controller_ops;
+	nfc->dev = dev;
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "nfi");
+	nfc->nfi_regs = devm_ioremap_resource(dev, res);
+	if (IS_ERR(nfc->nfi_regs)) {
+		ret = PTR_ERR(nfc->nfi_regs);
+		return ret;
+	}
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "ecc");
+	nfc->ecc_regs = devm_ioremap_resource(dev, res);
+	if (IS_ERR(nfc->ecc_regs)) {
+		ret = PTR_ERR(nfc->ecc_regs);
+		return ret;
+	}
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "addr");
+	nfc->addr_reg = devm_ioremap_resource(dev, res);
+	if (IS_ERR(nfc->addr_reg)) {
+		ret = PTR_ERR(nfc->addr_reg);
+		return ret;
+	}
+
+	nfc->nfi_clk = devm_clk_get(dev, "nfi_clk");
+	if (IS_ERR(nfc->nfi_clk)) {
+		dev_warn(dev, "nfi clk not provided\n");
+		nfc->nfi_clk = NULL;
+	} else {
+		ret = clk_prepare_enable(nfc->nfi_clk);
+		if (ret) {
+			dev_err(dev, "Failed to enable nfi core clock\n");
+			return ret;
+		}
+	}
+
+	nfc->irq = platform_get_irq_optional(pdev, 0);
+	if (nfc->irq < 0)
+		return nfc->irq;
+
+	platform_set_drvdata(pdev, nfc);
+
+	ret = ralink_nfc_init_chip(nfc);
+	if (ret) {
+		dev_err(dev, "Failed to initialize nand chip\n");
+		goto clk_disable;
+	}
+
+	return 0;
+
+clk_disable:
+	clk_disable_unprepare(nfc->nfi_clk);
+
+	return ret;
+}
+
+static int ralink_nfc_remove(struct platform_device *pdev)
+{
+	struct ralink_nfc *nfc = platform_get_drvdata(pdev);
+
+	nand_release(&nfc->nand);
+	clk_disable_unprepare(nfc->nfi_clk);
+
+	return 0;
+}
+
+static const struct of_device_id ralink_nfc_id_table[] = {
+	{ .compatible = "ralink,mt7620a-nfc" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, match);
+
+static struct platform_driver ralink_nfc_driver = {
+	.probe = ralink_nfc_probe,
+	.remove = ralink_nfc_remove,
+	.driver = {
+		.name = MODULE_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = ralink_nfc_id_table,
+	},
+};
+
+module_platform_driver(ralink_nfc_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Weijie Gao <weijie.gao@mediatek.com>");
+MODULE_DESCRIPTION("Ralink NAND Flash Controller driver");
--- /dev/null
+++ b/drivers/mtd/nand/raw/ralink_nand.h
@@ -0,0 +1,177 @@
+#ifndef RT2880_NAND_H
+#define RT2880_NAND_H
+
+//#include "gdma.h"
+
+#define MODULE_NAME			"ralink-nand"
+
+//#define RALINK_SYSCTL_BASE		0xB0000000
+//#define RALINK_PIO_BASE		0xB0000600
+//#define RALINK_NAND_CTRL_BASE		0xB0000810
+
+//#define CONFIG_RALINK_MT7620
+
+#define ACCTIMING(tpoecs, tprecs, tc2r, tw2r, twh, twst, trlt) \
+	((tpoecs) << ACCCON_POECS_S | (tprecs) << ACCCON_PRECS_S | \
+	(tc2r) << ACCCON_C2R_S | (tw2r) << ACCCON_W2R_S | \
+	(twh) << ACCCON_WH_S | (twst) << ACCCON_WST_S | (trlt))
+
+#define MASTER_STA_MASK			(MAS_ADDR | MAS_RD | MAS_WR | MAS_RDDLY)
+
+#define NFI_RESET_TIMEOUT		1000000
+#define NFI_CORE_TIMEOUT		500000
+#define ECC_ENGINE_TIMEOUT		500000
+
+#define ECC_SECTOR_SIZE			512
+#define ECC_PARITY_BITS			13
+
+#define NFI_FDM_SIZE			4
+
+#define SKIP_BAD_BLOCK
+//#define RANDOM_GEN_BAD_BLOCK
+
+#define ra_inl(addr)  (*(volatile unsigned int *)(addr))
+#define ra_outl(addr, value)  (*(volatile unsigned int *)(addr) = (value))
+#define ra_aor(addr, a_mask, o_value)  ra_outl(addr, (ra_inl(addr) & (a_mask)) | (o_value))
+#define ra_and(addr, a_mask)  ra_aor(addr, a_mask, 0)
+#define ra_or(addr, o_value)  ra_aor(addr, -1, o_value)
+
+#define CONFIG_NUMCHIPS 1
+#define CONFIG_NOT_SUPPORT_WP //rt3052 has no WP signal for chip.
+//#define CONFIG_NOT_SUPPORT_RB
+
+extern int is_nand_page_2048;
+extern const unsigned int nand_size_map[2][3];
+
+//chip
+// chip geometry: SAMSUNG small size 32MB.
+#define CONFIG_CHIP_SIZE_BIT (nand_size_map[is_nand_page_2048][nand_addrlen-3]) //! (1<<NAND_SIZE_BYTE) MB
+//#define CONFIG_CHIP_SIZE_BIT (is_nand_page_2048? 29 : 25)	//! (1<<NAND_SIZE_BYTE) MB
+#define CONFIG_PAGE_SIZE_BIT (is_nand_page_2048? 11 : 9)	//! (1<<PAGE_SIZE) MB
+//#define CONFIG_SUBPAGE_BIT 1		//! these bits will be compensate by command cycle
+#define CONFIG_NUMPAGE_PER_BLOCK_BIT (is_nand_page_2048? 6 : 5)	//! order of number of pages a block.
+#define CONFIG_OOBSIZE_PER_PAGE_BIT (is_nand_page_2048? 6 : 4)	//! byte number of oob a page.
+#define CONFIG_BAD_BLOCK_POS (is_nand_page_2048? 0 : 4)     //! offset of byte to denote bad block.
+#define CONFIG_ECC_BYTES 3      //! ecc has 3 bytes
+#define CONFIG_ECC_OFFSET (is_nand_page_2048? 6 : 5)        //! ecc starts from offset 5.
+
+//this section should not be modified.
+//#define CFG_COLUMN_ADDR_MASK ((1 << (CONFIG_PAGE_SIZE_BIT - CONFIG_SUBPAGE_BIT)) - 1)
+//#define CFG_COLUMN_ADDR_CYCLE (((CONFIG_PAGE_SIZE_BIT - CONFIG_SUBPAGE_BIT) + 7)/8)
+//#define CFG_ROW_ADDR_CYCLE ((CONFIG_CHIP_SIZE_BIT - CONFIG_PAGE_SIZE_BIT + 7)/8)
+//#define CFG_ADDR_CYCLE (CFG_COLUMN_ADDR_CYCLE + CFG_ROW_ADDR_CYCLE)
+
+#define CFG_COLUMN_ADDR_CYCLE   (is_nand_page_2048? 2 : 1)
+#define CFG_ROW_ADDR_CYCLE      (nand_addrlen - CFG_COLUMN_ADDR_CYCLE)
+#define CFG_ADDR_CYCLE (CFG_COLUMN_ADDR_CYCLE + CFG_ROW_ADDR_CYCLE)
+
+#define CFG_CHIPSIZE    (1 << ((CONFIG_CHIP_SIZE_BIT>=32)? 31 : CONFIG_CHIP_SIZE_BIT))
+//#define CFG_CHIPSIZE  	(1 << CONFIG_CHIP_SIZE_BIT)
+#define CFG_PAGESIZE	(1 << CONFIG_PAGE_SIZE_BIT)
+#define CFG_BLOCKSIZE 	(CFG_PAGESIZE << CONFIG_NUMPAGE_PER_BLOCK_BIT)
+#define CFG_NUMPAGE	(1 << (CONFIG_CHIP_SIZE_BIT - CONFIG_PAGE_SIZE_BIT))
+#define CFG_NUMBLOCK	(CFG_NUMPAGE >> CONFIG_NUMPAGE_PER_BLOCK_BIT)
+#define CFG_BLOCK_OOBSIZE	(1 << (CONFIG_OOBSIZE_PER_PAGE_BIT + CONFIG_NUMPAGE_PER_BLOCK_BIT))
+#define CFG_PAGE_OOBSIZE	(1 << CONFIG_OOBSIZE_PER_PAGE_BIT)
+
+#define NAND_BLOCK_ALIGN(addr) ((addr) & (CFG_BLOCKSIZE-1))
+#define NAND_PAGE_ALIGN(addr) ((addr) & (CFG_PAGESIZE-1))
+
+
+#define NFC_CTRL	(0x0)
+#define NFC_CONF	(0x4)
+#define NFC_CMD1	(0x8)
+#define NFC_CMD2	(0xc)
+#define NFC_CMD3	(0x10)
+#define NFC_ADDR	(0x14)
+#define NFC_DATA	(0x18)
+//#if defined (CONFIG_RALINK_RT6855) || defined (CONFIG_RALINK_RT6855A) || \
+//	defined (CONFIG_RALINK_MT7620) || defined (CONFIG_RALINK_MT7621)
+#define NFC_ECC		(0x30)
+//#else
+#define NFC_ECC0	(0x1c)
+//#endif
+#define NFC_STATUS	(0x20)
+#define NFC_INT_EN	(0x24)
+#define NFC_INT_ST	(0x28)
+//#if defined (CONFIG_RALINK_RT6855) || defined (CONFIG_RALINK_RT6855A) || \
+//	defined (CONFIG_RALINK_MT7620) || defined (CONFIG_RALINK_MT7621)
+#define NFC_CONF1	(0x2c)
+#define NFC_ECC_P1	(NFC_ECC + 0x0)
+#define NFC_ECC_P2	(NFC_ECC + 0x4)
+#define NFC_ECC_P3	(NFC_ECC + 0x8)
+#define NFC_ECC_P4	(NFC_ECC + 0xc)
+#define NFC_ECC_ERR1	(NFC_ECC + 0x10)
+#define NFC_ECC_ERR2	(NFC_ECC + 0x14)
+#define NFC_ECC_ERR3	(NFC_ECC + 0x18)
+#define NFC_ECC_ERR4	(NFC_ECC + 0x1c)
+#define NFC_ADDR2	(0x50)
+//#endif
+
+enum _int_stat {
+	INT_ST_ND_DONE		= 1<<0,
+	INT_ST_TX_BUF_RDY	= 1<<1,
+	INT_ST_RX_BUF_RDY	= 1<<2,
+	INT_ST_ECC_ERR		= 1<<3,
+	INT_ST_TX_TRAS_ERR	= 1<<4,
+	INT_ST_RX_TRAS_ERR	= 1<<5,
+	INT_ST_TX_KICK_ERR	= 1<<6,
+	INT_ST_RX_KICK_ERR	= 1<<7
+};
+
+
+//#define WORKAROUND_RX_BUF_OV 1
+
+
+typedef enum _ra_flags {
+	FLAG_NONE	= 0,
+	FLAG_ECC_EN 	= (1<<0),
+	FLAG_USE_GDMA 	= (1<<1),
+	FLAG_VERIFY 	= (1<<2),
+} RA_FLAGS;
+
+
+#define BBTTAG_BITS		2
+#define BBTTAG_BITS_MASK	((1<<BBTTAG_BITS) -1)
+enum BBT_TAG {
+	BBT_TAG_UNKNOWN = 0, //2'b01
+	BBT_TAG_GOOD	= 3, //2'b11
+	BBT_TAG_BAD	= 2, //2'b10
+	BBT_TAG_RES	= 1, //2'b01
+};
+
+struct ra_nand_chip {
+	int	numchips;
+	int 	chip_shift;
+	int	page_shift;
+	int 	erase_shift;
+	int 	oob_shift;
+	int	badblockpos;
+#if !defined (__UBOOT__)
+	struct mutex hwcontrol;
+	struct mutex *controller;
+#endif
+	struct nand_ecclayout	*oob;
+	int 	state;
+	unsigned int 	buffers_page;
+	char	*buffers; //[CFG_PAGESIZE + CFG_PAGE_OOBSIZE];
+	char 	*readback_buffers;
+	unsigned char 	*bbt;
+#if defined (WORKAROUND_RX_BUF_OV)
+	unsigned int	 sandbox_page;	// steal a page (block) for read ECC verification
+#endif
+
+};
+
+
+
+//fixme, gdma api
+int nand_dma_sync(void);
+void release_dma_buf(void);
+int set_gdma_ch(unsigned long dst,
+		unsigned long src, unsigned int len, int burst_size,
+		int soft_mode, int src_req_type, int dst_req_type,
+		int src_burst_mode, int dst_burst_mode);
+
+
+#endif
