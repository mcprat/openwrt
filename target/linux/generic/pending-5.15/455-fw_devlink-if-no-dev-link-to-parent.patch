--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -108,6 +108,31 @@ int fwnode_link_add(struct fwnode_handle
 	return ret;
 }
 
+int __fwnode_link_to_parents(struct fwnode_handle *con, struct fwnode_handle *sup,
+			     bool loop)
+{
+	int ret = -EINVAL;
+	struct fwnode_handle *parent;
+
+	fwnode_for_each_parent_node(sup, parent) {
+		/* Ignore the root node */
+		if (fwnode_count_parents(parent) &&
+		    fwnode_device_is_available(parent) &&
+		  !(parent->flags & FWNODE_FLAG_NOT_DEVICE) &&
+		  !(parent->flags & FWNODE_FLAG_PARENT_IS_DEV)) {
+			if (!__fwnode_link_add(con, parent))
+				ret = 0;
+		}
+
+		if (!loop && !ret) {
+			fwnode_handle_put(parent);
+			return 0;
+		}
+	}
+
+	return ret;
+}
+
 /**
  * __fwnode_link_del - Delete a link between two fwnode_handles.
  * @link: the fwnode_link to be deleted
@@ -222,6 +247,7 @@ static void __fw_devlink_pickup_dangling
 		return;
 
 	fwnode->flags |= FWNODE_FLAG_NOT_DEVICE;
+	fwnode->flags |= FWNODE_FLAG_PARENT_IS_DEV;
 	__fwnode_links_move_consumers(fwnode, new_sup);
 
 	fwnode_for_each_available_child_node(fwnode, child)
@@ -1821,6 +1847,13 @@ static int fw_devlink_create_devlink(str
 	struct device *sup_dev;
 	int ret = 0;
 
+	if (sup_handle->flags & FWNODE_FLAG_NOT_DEVICE) {
+		if (__fwnode_link_to_parents(con->fwnode, sup_handle, false))
+			return -EAGAIN;
+		else
+			return -EINVAL;
+	}
+
 	/*
 	 * In some cases, a device P might also be a supplier to its child node
 	 * C. However, this would defer the probe of C until the probe of P
--- a/drivers/of/property.c
+++ b/drivers/of/property.c
@@ -1128,7 +1128,8 @@ static int of_link_to_phandle(struct dev
 	sup_dev = get_dev_from_fwnode(&sup_np->fwnode);
 	if (!sup_dev &&
 	    (of_node_check_flag(sup_np, OF_POPULATED) ||
-	     sup_np->fwnode.flags & FWNODE_FLAG_NOT_DEVICE)) {
+	   ((sup_np->fwnode.flags & FWNODE_FLAG_NOT_DEVICE) &&
+	   !(sup_np->fwnode.flags & FWNODE_FLAG_PARENT_IS_DEV)))) {
 		pr_debug("Not linking %pOFP to %pOFP - No struct device\n",
 			 con_np, sup_np);
 		of_node_put(sup_np);
--- a/include/linux/fwnode.h
+++ b/include/linux/fwnode.h
@@ -26,11 +26,15 @@ struct device;
  *			     driver needs its child devices to be bound with
  *			     their respective drivers as soon as they are
  *			     added.
+ * PARENT_IS_DEV: The fwnode is a child of a fwnode that got populated as a
+ *		  struct device, which is likely more suitable for device links
+ *		  than the fwnode child which may never have a struct device
  */
 #define FWNODE_FLAG_LINKS_ADDED			BIT(0)
 #define FWNODE_FLAG_NOT_DEVICE			BIT(1)
 #define FWNODE_FLAG_INITIALIZED			BIT(2)
 #define FWNODE_FLAG_NEEDS_CHILD_BOUND_ON_ADD	BIT(3)
+#define FWNODE_FLAG_PARENT_IS_DEV		BIT(4)
 
 struct fwnode_handle {
 	struct fwnode_handle *secondary;
