--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -98,12 +98,41 @@ static int __fwnode_link_add(struct fwno
 	return 0;
 }
 
+int __fwnode_link_to_parents(struct fwnode_handle *con, struct fwnode_handle *sup,
+			     bool loop)
+{
+	int ret = -EINVAL;
+	struct fwnode_handle *parent;
+
+	fwnode_for_each_parent_node(sup, parent) {
+		/* Ignore the root node */
+		if (fwnode_count_parents(parent) &&
+		    fwnode_device_is_available(parent) &&
+		  !(parent->flags & FWNODE_FLAG_NOT_DEVICE) &&
+		  !(parent->flags & FWNODE_FLAG_PARENT_IS_DEV)) {
+			ret = __fwnode_link_add(con, parent);
+		}
+
+		if (!loop && !ret) {
+			fwnode_handle_put(parent);
+			return 0;
+		}
+	}
+
+	return ret;
+}
+
 int fwnode_link_add(struct fwnode_handle *con, struct fwnode_handle *sup)
 {
 	int ret = 0;
 
 	mutex_lock(&fwnode_link_lock);
-	ret = __fwnode_link_add(con, sup);
+
+	if (sup->flags & FWNODE_FLAG_NOT_DEVICE)
+		ret = __fwnode_link_to_parents(con, sup, false);
+	else
+		ret = __fwnode_link_add(con, sup);
+
 	mutex_unlock(&fwnode_link_lock);
 	return ret;
 }
@@ -206,22 +235,18 @@ static void __fwnode_links_move_consumer
  * @fwnode: fwnode from which to pick up dangling consumers
  * @new_sup: fwnode of new supplier
  *
- * If the @fwnode has a corresponding struct device and the device supports
- * probing (that is, added to a bus), then we want to let fw_devlink create
- * MANAGED device links to this device, so leave @fwnode and its descendant's
- * fwnode links alone.
- *
- * Otherwise, move its consumers to the new supplier @new_sup.
+ * Flag descendants of @fwnode as having a parent fwnode as a probeable device
+ * and move existing fwnode consumer links from @fwnode to @new_sup
  */
 static void __fw_devlink_pickup_dangling_consumers(struct fwnode_handle *fwnode,
 						   struct fwnode_handle *new_sup)
 {
 	struct fwnode_handle *child;
 
-	if (fwnode->dev && fwnode->dev->bus)
+	if (fwnode->dev && fwnode->dev->driver)
 		return;
 
-	fwnode->flags |= FWNODE_FLAG_NOT_DEVICE;
+	fwnode->flags |= FWNODE_FLAG_PARENT_IS_DEV;
 	__fwnode_links_move_consumers(fwnode, new_sup);
 
 	fwnode_for_each_available_child_node(fwnode, child)
@@ -1821,6 +1846,9 @@ static int fw_devlink_create_devlink(str
 	struct device *sup_dev;
 	int ret = 0;
 
+	if (sup_handle->flags & FWNODE_FLAG_NOT_DEVICE)
+		return -EINVAL;
+
 	/*
 	 * In some cases, a device P might also be a supplier to its child node
 	 * C. However, this would defer the probe of C until the probe of P
--- a/drivers/of/property.c
+++ b/drivers/of/property.c
@@ -1128,7 +1128,8 @@ static int of_link_to_phandle(struct dev
 	sup_dev = get_dev_from_fwnode(&sup_np->fwnode);
 	if (!sup_dev &&
 	    (of_node_check_flag(sup_np, OF_POPULATED) ||
-	     sup_np->fwnode.flags & FWNODE_FLAG_NOT_DEVICE)) {
+	   ((sup_np->fwnode.flags & FWNODE_FLAG_NOT_DEVICE) &&
+	   !(sup_np->fwnode.flags & FWNODE_FLAG_PARENT_IS_DEV)))) {
 		pr_debug("Not linking %pOFP to %pOFP - No struct device\n",
 			 con_np, sup_np);
 		of_node_put(sup_np);
--- a/include/linux/fwnode.h
+++ b/include/linux/fwnode.h
@@ -26,11 +26,15 @@ struct device;
  *			     driver needs its child devices to be bound with
  *			     their respective drivers as soon as they are
  *			     added.
+ * PARENT_IS_DEV: The fwnode is a child of a fwnode that got populated as a
+ *		  struct device, which is likely more suitable for device links
+ *		  than the fwnode child which may never have a struct device
  */
 #define FWNODE_FLAG_LINKS_ADDED			BIT(0)
 #define FWNODE_FLAG_NOT_DEVICE			BIT(1)
 #define FWNODE_FLAG_INITIALIZED			BIT(2)
 #define FWNODE_FLAG_NEEDS_CHILD_BOUND_ON_ADD	BIT(3)
+#define FWNODE_FLAG_PARENT_IS_DEV		BIT(4)
 
 struct fwnode_handle {
 	struct fwnode_handle *secondary;
