--- a/lib/xmalloc.c
+++ b/lib/xmalloc.c
@@ -51,12 +51,6 @@ ximalloc (idx_t s)
   return nonnull (imalloc (s));
 }
 
-char *
-xcharalloc (size_t n)
-{
-  return XNMALLOC (n, char);
-}
-
 /* Change the size of an allocated block of memory P to S bytes,
    with error checking.  */
 
@@ -75,135 +69,6 @@ xirealloc (void *p, idx_t s)
   return nonnull (irealloc (p, s));
 }
 
-/* Change the size of an allocated block of memory P to an array of N
-   objects each of S bytes, with error checking.  */
-
-void *
-xreallocarray (void *p, size_t n, size_t s)
-{
-  void *r = reallocarray (p, n, s);
-  if (!r && (!p || (n && s)))
-    xalloc_die ();
-  return r;
-}
-
-void *
-xireallocarray (void *p, idx_t n, idx_t s)
-{
-  return nonnull (ireallocarray (p, n, s));
-}
-
-/* Allocate an array of N objects, each with S bytes of memory,
-   dynamically, with error checking.  S must be nonzero.  */
-
-void *
-xnmalloc (size_t n, size_t s)
-{
-  return xreallocarray (NULL, n, s);
-}
-
-void *
-xinmalloc (idx_t n, idx_t s)
-{
-  return xireallocarray (NULL, n, s);
-}
-
-/* If P is null, allocate a block of at least *PS bytes; otherwise,
-   reallocate P so that it contains more than *PS bytes.  *PS must be
-   nonzero unless P is null.  Set *PS to the new block's size, and
-   return the pointer to the new block.  *PS is never set to zero, and
-   the returned pointer is never null.  */
-
-void *
-x2realloc (void *p, size_t *ps)
-{
-  return x2nrealloc (p, ps, 1);
-}
-
-/* If P is null, allocate a block of at least *PN such objects;
-   otherwise, reallocate P so that it contains more than *PN objects
-   each of S bytes.  S must be nonzero.  Set *PN to the new number of
-   objects, and return the pointer to the new block.  *PN is never set
-   to zero, and the returned pointer is never null.
-
-   Repeated reallocations are guaranteed to make progress, either by
-   allocating an initial block with a nonzero size, or by allocating a
-   larger block.
-
-   In the following implementation, nonzero sizes are increased by a
-   factor of approximately 1.5 so that repeated reallocations have
-   O(N) overall cost rather than O(N**2) cost, but the
-   specification for this function does not guarantee that rate.
-
-   Here is an example of use:
-
-     int *p = NULL;
-     size_t used = 0;
-     size_t allocated = 0;
-
-     void
-     append_int (int value)
-       {
-         if (used == allocated)
-           p = x2nrealloc (p, &allocated, sizeof *p);
-         p[used++] = value;
-       }
-
-   This causes x2nrealloc to allocate a block of some nonzero size the
-   first time it is called.
-
-   To have finer-grained control over the initial size, set *PN to a
-   nonzero value before calling this function with P == NULL.  For
-   example:
-
-     int *p = NULL;
-     size_t used = 0;
-     size_t allocated = 0;
-     size_t allocated1 = 1000;
-
-     void
-     append_int (int value)
-       {
-         if (used == allocated)
-           {
-             p = x2nrealloc (p, &allocated1, sizeof *p);
-             allocated = allocated1;
-           }
-         p[used++] = value;
-       }
-
-   */
-
-void *
-x2nrealloc (void *p, size_t *pn, size_t s)
-{
-  size_t n = *pn;
-
-  if (! p)
-    {
-      if (! n)
-        {
-          /* The approximate size to use for initial small allocation
-             requests, when the invoking code specifies an old size of
-             zero.  This is the largest "small" request for the GNU C
-             library malloc.  */
-          enum { DEFAULT_MXFAST = 64 * sizeof (size_t) / 4 };
-
-          n = DEFAULT_MXFAST / s;
-          n += !n;
-        }
-    }
-  else
-    {
-      /* Set N = floor (1.5 * N) + 1 to make progress even if N == 0.  */
-      if (ckd_add (&n, n, (n >> 1) + 1))
-        xalloc_die ();
-    }
-
-  p = xreallocarray (p, n, s);
-  *pn = n;
-  return p;
-}
 
 /* Grow PA, which points to an array of *PN items, and return the
    location of the reallocated array, updating *PN to reflect its
--- /dev/null
+++ b/lib/xrealloc.c
@@ -0,0 +1,174 @@
+/* xrealloc.c -- xalloc functions using reallocarray()
+
+   Copyright (C) 1990-2000, 2002-2006, 2008-2024 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+#include <config.h>
+
+#define XALLOC_INLINE _GL_EXTERN_INLINE
+
+#include "xalloc.h"
+
+#include "ialloc.h"
+#include "minmax.h"
+
+#include <stdckdint.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+
+static void * _GL_ATTRIBUTE_PURE
+nonnull (void *p)
+{
+  if (!p)
+    xalloc_die ();
+  return p;
+}
+
+/* Change the size of an allocated block of memory P to an array of N
+   objects each of S bytes, with error checking.  */
+
+void *
+xreallocarray (void *p, size_t n, size_t s)
+{
+  void *r = reallocarray (p, n, s);
+  if (!r && (!p || (n && s)))
+    xalloc_die ();
+  return r;
+}
+
+void *
+xireallocarray (void *p, idx_t n, idx_t s)
+{
+  return nonnull (ireallocarray (p, n, s));
+}
+
+/* Allocate an array of N objects, each with S bytes of memory,
+   dynamically, with error checking.  S must be nonzero.  */
+
+void *
+xnmalloc (size_t n, size_t s)
+{
+  return xreallocarray (NULL, n, s);
+}
+
+void *
+xinmalloc (idx_t n, idx_t s)
+{
+  return xireallocarray (NULL, n, s);
+}
+
+/* If P is null, allocate a block of at least *PN such objects;
+   otherwise, reallocate P so that it contains more than *PN objects
+   each of S bytes.  S must be nonzero.  Set *PN to the new number of
+   objects, and return the pointer to the new block.  *PN is never set
+   to zero, and the returned pointer is never null.
+
+   Repeated reallocations are guaranteed to make progress, either by
+   allocating an initial block with a nonzero size, or by allocating a
+   larger block.
+
+   In the following implementation, nonzero sizes are increased by a
+   factor of approximately 1.5 so that repeated reallocations have
+   O(N) overall cost rather than O(N**2) cost, but the
+   specification for this function does not guarantee that rate.
+
+   Here is an example of use:
+
+     int *p = NULL;
+     size_t used = 0;
+     size_t allocated = 0;
+
+     void
+     append_int (int value)
+       {
+         if (used == allocated)
+           p = x2nrealloc (p, &allocated, sizeof *p);
+         p[used++] = value;
+       }
+
+   This causes x2nrealloc to allocate a block of some nonzero size the
+   first time it is called.
+
+   To have finer-grained control over the initial size, set *PN to a
+   nonzero value before calling this function with P == NULL.  For
+   example:
+
+     int *p = NULL;
+     size_t used = 0;
+     size_t allocated = 0;
+     size_t allocated1 = 1000;
+
+     void
+     append_int (int value)
+       {
+         if (used == allocated)
+           {
+             p = x2nrealloc (p, &allocated1, sizeof *p);
+             allocated = allocated1;
+           }
+         p[used++] = value;
+       }
+
+   */
+
+void *
+x2nrealloc (void *p, size_t *pn, size_t s)
+{
+  size_t n = *pn;
+
+  if (! p)
+    {
+      if (! n)
+        {
+          /* The approximate size to use for initial small allocation
+             requests, when the invoking code specifies an old size of
+             zero.  This is the largest "small" request for the GNU C
+             library malloc.  */
+          enum { DEFAULT_MXFAST = 64 * sizeof (size_t) / 4 };
+
+          n = DEFAULT_MXFAST / s;
+          n += !n;
+        }
+    }
+  else
+    {
+      /* Set N = floor (1.5 * N) + 1 to make progress even if N == 0.  */
+      if (ckd_add (&n, n, (n >> 1) + 1))
+        xalloc_die ();
+    }
+
+  p = xreallocarray (p, n, s);
+  *pn = n;
+  return p;
+}
+
+/* If P is null, allocate a block of at least *PS bytes; otherwise,
+   reallocate P so that it contains more than *PS bytes.  *PS must be
+   nonzero unless P is null.  Set *PS to the new block's size, and
+   return the pointer to the new block.  *PS is never set to zero, and
+   the returned pointer is never null.  */
+
+void *
+x2realloc (void *p, size_t *ps)
+{
+  return x2nrealloc (p, ps, 1);
+}
+
+char *
+xcharalloc (size_t n)
+{
+  return XNMALLOC (n, char);
+}
--- a/modules/xalloc
+++ b/modules/xalloc
@@ -15,7 +15,7 @@ idx
 malloc-gnu
 minmax
 realloc-gnu
-reallocarray
+xreallocarray
 stdckdint
 stdint
 xalloc-die
--- /dev/null
+++ b/modules/xreallocarray
@@ -0,0 +1,24 @@
+Description:
+xalloc functions that depend on reallocarray()
+
+Files:
+lib/xalloc.h
+lib/xrealloc.c
+
+Depends-on:
+reallocarray
+xalloc-die
+
+configure.ac:
+
+Makefile.am:
+lib_SOURCES += xrealloc.c
+
+Include:
+"xalloc.h"
+
+License:
+GPL
+
+Maintainer:
+all
